# -*- coding: utf-8 -*-
"""IMDB data exploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yrfHSQYUMxxLKGUG-gCPf-R232BuimiR

# IMDB data exploration

---
"""

!pip install --upgrade gdown

!gdown 1s2TkjSpzNc4SyxqRrQleZyDIHlc7bxnd
!gdown 1Ws-_s1fHZ9nHfGLVUQurbHDvStePlEJm

import pandas as pd
import numpy as np

movies = pd.read_csv('movies.csv', index_col=0)
directors = pd.read_csv('directors.csv', index_col=0)

data = movies.merge(directors, how='left', left_on='director_id', right_on='id')
data.drop(['director_id','id_y'], axis=1, inplace=True)

"""Let's explore all the features in the merged dataset."""

data.info()

"""Looks like only `gender` column has missing values (will come later).

#### How can we describe these features to know more about their range of values?
"""

data.describe()

"""This gives us all **statistics** related to these columns.

Notice that some columns such as `title`, `month` are missing.

How are these missing columns different?

- They are of **object dtype**.

#### How can we include object type in `df.describe()`?
"""

data.describe(include=object)

"""If you notice,
- The range of values in the `revenue` and `budget` columns seem to be very high.
- Generally, the budget and revenue for hollywood movies is in millions of dollars.

#### How can we change the values of `revenue` and `budget` into million dollars USD?

"""

data['revenue'] = (data['revenue']/1000000).round(2)
data

"""Similarly, we can do it for the `budget` as well."""

data['budget']=(data['budget']/1000000).round(2)
data.head()

"""Let's say we are interested in fetching all the **highly rated movies**

- movies with **ratings > 7**

#### How can we get movies with ratings greater than 7?

We can use the concept of `masking`.

Lets first create a mask to filter such movies.

- In SQL, we can do `SELECT * FROM movies WHERE vote_average>7`
- In Pandas
"""

data['vote_average'] > 7

"""But we still don't know the row values... Only that which row satisfies the condtion.

#### How do we get the row values from this mask?
"""

data.loc[data['vote_average'] > 7]

"""You can also perform the filtering without using `loc`.



"""

data[data['vote_average'] > 7]

"""But this is not recommended. Why?

- It can create confusion between **implicit/explicit indexing** as discussed before.
- `loc` is also much faster.

#### Hhow can we return a subset of columns, say only `title` and `director_name`?
"""

data.loc[data['vote_average'] > 7, ['title','director_name']]

"""So far, we've only seen single condition based filtering.

#### What if we want to filter highly rated movies released after 2014?

Notice that two different conditions are involved here.

1. Movies should be highly rated i.e. ratings > 7
2. Movies should be released either in the year 2015 or later.

We can use the `&` operator to combine multiple conditions.
"""

data.loc[(data['vote_average'] > 7) & (data['year'] >= 2015)].head()

"""Recall how we apply mutliple conditions in Numpy?

- Use **element-wise operator `&` or `|`**

**Note:** For specifying multiple conditions, we need to put each separate condition within parenthesis `()`.

#### How can we find movies released on either Friday or Sunday?
"""

data.loc[(data['day'] == 'Friday') | (data['day'] == 'Saturday')].head()

"""Thus, we can perform complex queries using both `&` and `|` operators.

Now let's try to answer few more questions from this data.

#### How will you find the Top 5 most popular movies?

- We can simply sort our data based on values of the `popularity` column.
"""

data.sort_values(['popularity'],ascending=False).head(5)

"""On applying this to a string column, it sorts the dataframe ***lexicographically**."""

data.sort_values(['title'],ascending=False).head(5)

"""#### How will get list of movies directed by a particular director, say 'Christopher Nolan'?"""

data.loc[data['director_name'] == 'Christopher Nolan',['title']]

"""**Note:**
- The string indicating "Christopher Nolan" could have been something else as well.  
- The better way is to use string methods. We will discuss this later.

---
"""