# -*- coding: utf-8 -*-
"""Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vFiyTV_iBdDqUI9_lq-m0EgpPg7EWrf9

**Q1. Smaller and larger class**

**Problem Description**

Complete the classes **Smaller** and **Larger**.

**Smaller class** gets instantiated when the argument of the function **(a:string) has a length smaller than 6** otherwise **Larger is instantiated**.
Both the classes have the same two methods, **display()** printing the type of a (**class**), and
**evaluate()** printing the **number of vowels if the Name is Smaller** otherwise it **prints the number of consonants**.


**Input Format**

> For each testcase there will be a single line of input which will be a string (it can contain both uppercase and lowercase alphabets).

**Output Format**

> For each testcase there will be two lines of outputs. First line will write the type of object and second line will print the output of evaluate() according to the object type. The type of Name is Smaller or Larger # Line 1 Number vowels or consonants # Line 2


**Example Input 1**

"aman"

**Example Output 1**

The type of Name is Smaller
2


**Example Explanation 1**

Since the length of "aman" is 4 which is smaller than 6, therefore, it will be called with Smaller class and in the second line evaluate() will print the frequency of vowels in the Name.

**Example Input 2**

"rajnandini"

**Example Output**

The type of Name is Larger
6

**Example Explanation**

Since the length of "rajnandini" is 10 which is larger than 6, therefore, it will be called with Larger class and in the second line evaluate() will print the frequency of consonants in the Name.
"""

VOWELS = "aeiou"

def vowels_count(string: str):
  string = string.lower()
  return len([char for char in string if char in VOWELS])

class Smaller:
    def __init__(self,a):
        self.string=a

    def display(self):
        print("The type of Name is Smaller")

    def evaluate(self):
        ans=0

        # YOUR CODE GOES HERE
        ans = vowels_count(self.string)
        print(ans)

class Larger:
    def __init__(self,a):
        self.string=a

    def display(self):
        print("The type of Name is Larger")

    def evaluate(self):
        ans=0

        # YOUR CODE GOES HERE
        ans = len(self.string) - vowels_count(self.string)
        print(ans)

def main(a):
    '''
    input a is string
    '''
    if len(a)<6:
        obj=Smaller(a)
        obj.display()
        obj.evaluate()
    else:
        obj=Larger(a)
        obj.display()
        obj.evaluate()

main("aman")
main("rajnandhini")
main("Itsreallynoone")

"""**Q2. Spanoftime class**

Complete the timeHandle() function by completing the Spanoftime class. Spanoftime class should fulfill the following two requirements:

1. Complete the method addTime which should take two Spanoftime objects, add them and return another Spanoftime object with added attributes (Hours and minutes). E.g.- (2 hour and 50 min)+(1 hr and 20 min) is (4 hr and 10 min)

2. Complete the method returnMinute which should return total minutes in the Spanoftime objects t1 and t2. E.g.- (1 hr 2 min and 1 hr 2 min) should return 124 minute.

timeHandle() has 4 parameters which are hours and minutes for two Spanoftime objects which are instantiated in the function itself.
"""

def timeHandle(a,b,c,d):
    '''inputs: a,b = hours and mins of t1
               c,d = hours and mins of t2
        Output: Two lines of output for each pair of t1 and t2. The code for printing outputs is already just make sure to return in the methods.'''
    # The code for taking input and printing output is already taken care of.

    class Spanoftime:
        def __init__(self,h,m):
            self.hours=h
            self.mins=m

        def displayTime(self):
            return ("{} hours and {} min".format(self.hours,self.mins))

        def addTime(t1,t2):
            t3=Spanoftime(0,0)
            # Complete the function
            total_mins = Spanoftime.returnMinutes(t1, t2)
            t3.hours = int(total_mins / 60)
            t3.mins = total_mins % 60
            return t3

        def returnMinutes(t1,t2):
            # Return the total number of minutes
            return t1.hours * 60 + t1.mins + t2.hours * 60 + t2.mins

    t1=Spanoftime(a,b)
    t2=Spanoftime(c,d)
    t3=Spanoftime.addTime(t1,t2)
    t3.displayTime()
    totalmin=str(Spanoftime.returnMinutes(t1,t2))
    return t3.displayTime(),("The total minutes in time t1 and t2 are: " + totalmin)

timeHandle(2, 50, 1, 20)

"""**Q3. inheritance in python**

What will be the output of the following code block?

```python
class A:
   def one(self):
       return self.two()
   def two(self):
       return 'A'
class B(A):
   def two(self):
       return 'B'
obj= B()
print(obj.one())
```
"""

class A:
   def one(self):
       return self.two()
   def two(self):
       return 'A'
class B(A):
   def two(self):
       return 'B'
obj= B()
print(obj.one())

"""**Q4. parent and child**

Fill in the blank space in the code snippet to get an output of 60?

```
class Parent:
  def __init__(self):
    pass
  def print(self):
    print("60")

class Child(Parent):
   ____________
   ____________ # This block has to be completed.

C=Child()
C.type()
```

*******Choose from below options*******

**A**
```
def __init__(self):
  super().__init__()
def type(self):
  self.print()
```

**B**
```
def __init__(self):
  super().__init__()
def type(self):
  self().print()
```

**C**
```
def __init__(self):
  super().__init__()
def type(self):
  super().print()
```

**D**
```
None of these
```
"""

class Parent:
  def __init__(self):
    pass
  def print(self):
    print("60")

class Child1(Parent):
  def __init__(self):
    super().__init__()

  def type(self):
    self.print() # This too works!

class Child2(Parent):
  def __init__(self):
    super().__init__()

  def type(self):
    super().print() # This too works!

C=Child1()
C.type()

C=Child2()
C.type()

"""**AQ1. Make noise**

What will be the output of the following code?

```python
class A:
 def __init__(self, name, sound="Grrrr"):
   self.name = name
   self.sound = sound

 def make_noise(self):
   print("{} says, {}".format(self.name,self.sound))

class B(A):
 def __init__(self, name="Rachel"):
   super().__init__(name, "Meow!")

 def make_noise(self,sound="Grrrr!"):
   print("{} says, {}".format(self.name, sound))

pet_cat = B()
pet_cat.make_noise()
```
"""

class A:
 def __init__(self, name, sound="Grrrr"):
   self.name = name
   self.sound = sound

 def make_noise(self):
   print("{} says, {}".format(self.name,self.sound))

class B(A):
 def __init__(self, name="Rachel"):
   super().__init__(name, "Meow!")

 def make_noise(self,sound="Grrrr!"):
   print("{} says, {}".format(self.name, sound))

pet_cat = B()
pet_cat.make_noise()

"""**AQ2. Props Inheritance**

ou are given a small code snippet from a game, BrickBreaker. The props.py is containing a class Props which has all the basic features common in every prop. You are also given a ball.py file containing the properties a ball should have in order to play the game.

**Props.py**

```python
class Props:
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

**Ball.py**

```python
class Ball(Props):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.shape = "o"
        self.number = 1
        self.vely = 0
        self.velx = 0

    def get_x(self):
        return self.x

    def get_y(self):
       return self.y

    def get_velx(self):
       return self.velx

    def get_vely(self):
       return self.vely
    
    def inc_velx(self):
       self.velx = self.velx+2
    
    def inc_vely(self):
       self.vely = self.vely+1
```

You need to find the output of the following code considering the given 2 files.

```python
obj_ball = Ball(27,3)

bx = obj_ball.get_x()
by = obj_ball.get_y()
b_velx = obj_ball.get_velx()
b_vely = obj_ball.get_vely()

print(bx, by, b_velx, b_vely)
```
"""

class Props:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class Ball(Props):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.shape = "o"
        self.number = 1
        self.vely = 0
        self.velx = 0

    def get_x(self):
        return self.x

    def get_y(self):
       return self.y

    def get_velx(self):
       return self.velx

    def get_vely(self):
       return self.vely

    def inc_velx(self):
       self.velx = self.velx+2

    def inc_vely(self):
       self.vely = self.vely+1

obj_ball = Ball(27,3)

bx = obj_ball.get_x()
by = obj_ball.get_y()
b_velx = obj_ball.get_velx()
b_vely = obj_ball.get_vely()

print(bx, by, b_velx, b_vely)

"""**AQ3. multiply function**

What will be the output of the following Python code?

```
class A:
    def __init__(self):
        self.multiply(15)
        print(self.i)

    def multiply(self, i):
        self.i = 4 * i

class B(A):
    def __init__(self):
        super().__init__()

    def multiply(self, i):
        self.i = 2 * i;

obj = B()
```
"""

class A:
    def __init__(self):
        self.multiply(15)
        print(self.i)

    def multiply(self, i):
        self.i = 4 * i

class B(A):
    def __init__(self):
        super().__init__()

    def multiply(self, i):
        self.i = 2 * i;

obj = B()

"""**AQ4. Inheritance using ML**

You are already given a class Machine_Learning with its constructor and a number of methods. You have to define a class **Supervised** which will inherit the MachineLearning class with the following data members and methods:


**Data Members:**

1. name: string
2. category: string

**Methods:**

1. Constructor: Initialize the data member and call the parent class constructor
2. getname(): Returns the data member name.
3. getcategory(): Returns the data member breed.
4. type(): Prints '**Supervised Learning Algorithm**'.

You also have to define a class **Unsupervised** which will also inherit the MachineLearning class with the same data members and methods as in Supervised, but the type() will have to print **Unsupervised Learning Algorithm** for this class.

**Input Format:**

4 strings each in a new line. First two strings are name and category for Supervised class object and the last two are for Unsupervised class object.

**Output Format:**

```
Name of class is printed for the two instantiated objects.
Category of class is printed for the two instantiated objects.
type() of class is printed for the two instantiated objects.
```

**Sample Input:**

```
Logistic Regression
Classification Algo
k-Means
Clustering Algo
```

**Sample output:**

```
Name: Logistic Regression
Category: Classification Algo
Supervised Learning Algorithm
Name: k-Means
Category: Clustering Algo
Unsupervised Learning Algorithm
```

**Sample's Explanation:**

For Linear Regression, Classification Algo the type of class is supervised therefore it's printed after its name and category. For k-Means, Clustering Algo the type of class is supervised therefore it's printed after its name and category.
"""

class MachineLearning:
    def __init__(self,name,category):
        self.name=name
        self.category=category

    def getname(self):
        return self.name

    def getcategory(self):
        return self.category

    def print(self):
        print("Name:",self.name)
        print("Category:",self.category)

class Supervised(MachineLearning):
    def __init__(self,name,category):
        #YOUR CODE GOES HERE
        super().__init__(name, category)
        self.print()

    def type(self):
        #YOUR CODE GOES HERE
        print('Supervised Learning Algorithm')

class Unsupervised(MachineLearning):
    def __init__(self,name,category):
        #YOUR CODE GOES HERE
        super().__init__(name, category)
        self.print()

    def type(self):
        #YOUR CODE GOES HERE
        print('Unsupervised Learning Algorithm')

def mlAnalogy(a,b,c,d):
    '''
    input=> a,b = name and category for Supervised class
            c,d = name and category for Unsupervised class
    output=> type() is called for both classes in the end, it should first print the Name and Category then the type of class in new lines
    '''

    obj1=Supervised(a,b)
    obj1.type()
    obj2=Unsupervised(c,d)
    obj2.type()

    return None

mlAnalogy('Logistic Regression','Classification Algo','k-Means','Clustering Algo')

"""**AQ5. Polymorphism**

What will be the output of the following Python code?

```python
class A:

  def __init__(self, x, y):

    self.x = x
    self.y = y

  def __str__(self):

    return 1
  def __eq__(self, other):

    return self.x * self.y == other.x * other.y

obj1 = A(9, 8)
obj2 = A(8, 9)
print(obj1 == obj2)
```
"""

class A:

  def __init__(self, x, y):

    self.x = x
    self.y = y

  def __str__(self):

    return 1
  def __eq__(self, other):

    return self.x * self.y == other.x * other.y

obj1 = A(9, 8)
obj2 = A(8, 9)
print(obj1 == obj2)

"""**AQ6. Zoo Animal Management System**"""

class Animal:
    def __init__(self, species, age, name):
        # write the method
        self.species = species
        self.age = age
        self.name = name

    def __str__(self):
        return f"Name: {self.name}, Species: {self.species}, Age: {self.age}"

# Compelte the class
class Bird(Animal):
    def __init__(self, species, age, name, can_fly):
        # complete the method
        super().__init__(species, age, name)
        self.can_fly = 'Yes' if can_fly else 'No'

    def __str__(self):
        # complete the method
        return f"{super().__str__()}, Can Fly: {self.can_fly}"

class Zoo:
    def __init__(self):
        # complete the method
        self.animals = []

    def add_animal(self, animal):
        # complete the method
        self.animals.append(animal)

    def list_animals(self):
        # complete the method
        for animal in self.animals:
            print(animal)

zoo = Zoo()
animal1 = Animal("Lion", 5, "Leo")
bird1 = Bird("Parrot", 2, "Polly", True)
zoo.add_animal(Animal("Leo", 5, "Lion"))
zoo.add_animal(Bird("Polly", 2, "Parrot", True))
zoo.add_animal(Bird("Pingu", 4, "Penguin", True))
zoo.list_animals()