# -*- coding: utf-8 -*-
"""lecture3-functional-programming-1-liveclass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tPoKwBk3hCuJM8AtshtdU0Mdgxvoy-FT

## Multiple Inheritance
"""

class A:
    def __init__(self, a):
        self.a = a

class B:
    def __init__(self, b):
        self.b = b

# C inherits from both A and B
class C(A, B):
    def __init__(self, a, b, c):
      # Assumption 1
      # super().__init__(a, b)

      # Assumption 2
      # super().__init__(a)
      # super().__init__(b)

      # Assumption 3
        A.__init__(self, a) # Syntax: Class_name.method_name()
        B.__init__(self, b)
        self.c = c

c1 = C(1,2,3)

c1.c

A

B

C

D

"""# Can you use the same method for Single Inheritance as well ?
# YES

## MRO (Method Resolution Order)
"""

class A:
    x = 320

class B(A):
    x = 120

class C(B):
    pass

class D(A):
    x = 5

class E(C, D):
    pass


e = E()
e.x

# E -> C -> B -> D -> A

E.__mro__

"""## Functional Programming"""

# Imperative Approach:

numbers = [1, 2, 3, 4]
squared_numbers = []
for num in numbers:
    squared_numbers.append(num*num)

squared_numbers

# Functional Approach:

numbers = [1, 2, 3, 4]

def squared(x):
  return x * x

sq_numbers_fp = list(map(squared, numbers)) # Syntax: map(func, iterator) Iterator: list, tuple, string, sets
sq_numbers_fp

# numbers = {A: '2', B: '4'}
# for items in numbers.items():
#   print(items)

def squared(x):
  return x * x

squared(2)

"""Why use functional programming?
1. Concise and Readable: With functional programming, you're often working with familiar mathematical functions. This makes code shorter and intuitive. For instance, the map, filter, and reduce functions in Python are direct implementations of functional programming concepts.

2. More Maintainable: Since there are no side effects from mutable data, tracking errors becomes simpler. Imagine not having to worry about a variable's value being unexpectedly changed elsewhere in your program!

3. Efficient: Without the constant need to update data states, some functional programs can outperform their imperative counterparts.

## Lambda fucnction
"""

## function_name = lambda arguments: expression

(lambda x: x**2)(2)

square_num = lambda x: x**2
square_num(3)

# lambda function

numbers = [1, 2, 3, 4]
squared_numbers = list(map(lambda x: x*x, numbers))
squared_numbers

## Lambda function to get the cube of a number

(lambda x: x**3)(3)

## Addition of two numbers. Write a lambda function for it.

(lambda a,b : a + b)(4,5)

## Multiply of two numbers. Write a lambda function for it.

(lambda a,b : a * b)(4,5)

# Ternary Operator

# if condition:
#     x
# else:
#     y

# x if condition else y -> Ternary Operator

(lambda x: x if x > 5 else 0)(10)

(lambda x: x if x > 5 else 0)(4)

a = [1,5,7,8,0,2,3,5]
a

sorted_a = sorted(a)
sorted_a

students = [
    {"name": "A", "marks": 50},
    {"name": "B", "marks": 100},
    {"name": "C", "marks": 40},
    {"name": "D", "marks": 70},
    {"name": "E", "marks": 60},
]

students[0]

students[0] > students[1]

get_value = lambda x: x["marks"]

get_value(students[0])

get_value(students[0]) > get_value(students[1])

students

sorted(students,
       key = lambda x: x["name"],
       reverse= True)

sorted([1,2,3,4,5], reverse=True)

sorted(students,
       key = lambda x: x["marks"],
       reverse= False)

students = [
    {"name": "A", "marks": 50},
    {"name": "B", "marks": 100},
    {"name": "C", "marks": 40},
    {"name": "D", "marks": 100},
    {"name": "E", "marks": 60},
]

sorted(students,
       key = lambda x: (x["marks"], x["name"]),
       reverse= True)

"""## Higher Order Function"""

def gen_exp(n):

    def exp(x):
        return x**n

    return exp

gen_exp(5)

type(gen_exp(5))

exp_5 = gen_exp(5)

exp_5(2)

def gen_exp(n):

    print(n)

    def exp(x):
        return x**n

    return exp

exp_5 = gen_exp(5)

exp_5(2)

def generate_square_function():
    def square(x):
        return x ** 2
    return square

# Create a square function using the higher-order function
calculate_square = generate_square_function()

# Now we can use calculate_square as a function to calculate the square of any number
result = calculate_square(5)
print(result)

numbers = [1,2,3,4,5]

list(map(str, numbers))

# Encapsulation

numbers= [1, 2, 3, 4]

def sq_num(numbers):
  squared_numbers = []
  for num in numbers:
      squared_numbers.append(num*num)

  return squared_numbers

sq_num(numbers)

print("String")

print(123)

