# -*- coding: utf-8 -*-
"""Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vFiyTV_iBdDqUI9_lq-m0EgpPg7EWrf9

**Q1. List Slicing**

After executing the code below the given word gets converted into a list of individual characters of the word called word_list, indexing on which elements of the list word_list would give us a sublist that forms the word "Data Science"?
"""

word = "Scaler Data Science Course"
word_list = list(word)
print(f"Ans = {"".join(word_list[7:19])}")

"""**Q2. Operations on list**

Given two arrays, some operations are performed on these arrays, and the following three arrays are obtained after the operations as output.
What are those operations that are performed on the arrays respectively?

```
arr1 = [1,2,3]
arr2 = [6,5,4]

I.   arr1   = [1,2,3,6,5,4]
II.  arr1   = [1,2,3,[6,5,4]]
III. arr2  = [4,5,6]
```

"""

arr1 = [1, 2, 3]
arr2 = [6, 5, 4]

print(f"I.   Extend   arr1   = {arr1 + arr2}")
print(f"II.  Append   arr1   = {arr1 + [arr2]}")
print(f"III. Reverse  arr2  = {arr2[::-1]}")

"""**Q3. Ceil and Floor II**

**Problem Description**

You are given a **list of numbers (sorted in ascending order) A** and an integer B.

You need to return a **list of size 2**, where the first element is the **ceil of B** and the second element is the **floor of B**.

* The first element (Ceil of B) is the smallest number from the list that is greater than or equal to B.
* The second element (Floor of B) is the largest number from the list that is smaller than or equal to B.

**Note:**

The **list A** and the **integer B** are already passed as an argument to the function. **User don't need to take any input**.
Just perform the task on the passed arguments and **return the required result**.
"""

def solve(A,B):
    #Your Code Goes Here
    # First do bin search and find ceil, floor locations
    l, r = (0, len(A) - 1)
    floor, ceil = (A[l], A[r])
    while l + 1 < r:
      mid = (l + r) // 2
      if A[mid] < B:
        l = mid
        floor = max(floor, A[l])
      else:
        r = mid
        ceil = min(ceil, A[r])
    if floor <= B and ceil >= B:
      print(f"(floor, ceil) = {(floor, ceil)}")
    else:
      print("(floor, ceil) not found!")
    return
A = [2, 2, 2]
B = 2
print(f"\n1. solve({A}, {B})")
solve(A, B)
A = [2]
B = 2
print(f"\n2. solve({A}, {B})")
solve(A, B)
A = [5, 6, 7]
B = 2
print(f"\n3. solve({A}, {B})")
solve(A, B)
A = [-10, -2, 1, 2, 5, 6]
B = 4
print(f"\n4. solve({A}, {B})")
solve(A, B)
A = [-10, -2, 1, 2, 5, 6]
B = 6
print(f"\n5. solve({A}, {B})")
solve(A, B)

"""**Q4. Add the matrices II**

**Problem Description**

You are given two matrices A & B of same size, you have to return another matrix which is the sum of A and B.

**Note:**
* Matrices are of same size means the number of **rows** and number of **columns** of both matrices **are equal**.
* The matrices A and B are already passed as an argument to the function. **Users don't need to take any input**. Just perform the task on the passed arguments and **return the required result**.
"""

def addMatrices(A, B):
    #Your Code Goes Here

    # Note: This technique is formally called **list comprehension** in python
    S = [[ca + cb for ca, cb in zip(ra, rb)] for ra, rb in zip(A, B)]
    return S

import pandas as pd

A = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]

B = [[9, 8, 7],
     [6, 5, 4],
     [3, 2, 1]]
C = addMatrices(A, B)
dfa = pd.DataFrame(A)
dfp = pd.DataFrame('+', index=dfa.index, columns=[' '])
dfb = pd.DataFrame(B)
dfeq = pd.DataFrame('=', index=dfb.index, columns=[' '])
dfc = pd.DataFrame(C)
print("\nTest 1\n")
print(pd.concat([dfa, dfp, dfb, dfeq, dfc], axis=1).to_string(index=False, header=False))
A = [[1, 2],
     [4, 5],
     [7, 8]]

B = [[9, 8],
     [6, 5],
     [3, 2]]
C = addMatrices(A, B)
dfa = pd.DataFrame(A)
dfb = pd.DataFrame(B)
dfc = pd.DataFrame(C)
print("\nTest 2\n")
print(pd.concat([dfa, dfp, dfb, dfeq, dfc], axis=1).to_string(index=False, header=False))

"""> **Important note:** This method/techinque is formally called **list comprehension** in python...

**Q5. Largest in each Row II**

**Problem Description**

```
Given a 2D array A of N rows and M columns. Find value of largest element in each row.
```

**Note:** The **2D array A** is already passed as an argument to the function. User **don't need to take any input**. Just perform the task on the passed arguments and **return the required result**.
"""

def largest(A):
    #Your Code Goes Here
    MAX = [max(ra) for ra in A]
    print(MAX)
    return

A = [[1, 2], [1, 3]]
largest(A)
A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
largest(A)
A = [[1, 2, 3]]
largest(A)

"""**AQ1. Slice the List**

What does the following slice return?

```python
[1, 3, 4, 4, 3, 1, 2, 3, 2][:6:2]
```
"""

[1, 3, 4, 4, 3, 1, 2, 3, 2][:6:2]

"""**AQ2. Slice the List - 2**

What does the following slice return?

```python
[1, 3, 4, 4, 3, 1, 2, 3, 2][:3]
```
"""

[1, 3, 4, 4, 3, 1, 2, 3, 2][:3]

"""**AQ3. Inverse of the Array II**

**Problem Description**

You are given an integer array **A**. Now your task is to find the **inverse of A**.

Now, the inverse of the array is A will be an array in which we change the
positions of the values as their indices and indices as values.

So, array **A = [2, 0, 1]**
- Now **2** is at index **0**. So, place **0** at index **2**.
- **0** is at index **1**. So, place **1** at index **0**.
- **1** is at index **2**. So, place **2** at index **1**.

So, the **inverse of A** will be **[1, 2, 0]**

**Note:** The integer array A is already passed as an argument to the function. **User don't need to take any input**. Just perform the task on the passed arguments and **return the required result**.

"""

def invert(A):
    # Your Code Goes Here
    AINV = A.copy()
    for idx, n in enumerate(A):
        AINV[n] = idx
    # print(AINV)
    return AINV

A = [2, 0, 1]
print(f"invert({A}) = {invert(A)}")
A = [3, 1, 0, 2]
print(f"invert({A}) = {invert(A)}")

"""**AQ4. Matrix Transpose II**

**Problem Description**

Given a 2D integer array A, return the transpose of A.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

**Note:** The 2D integer array **A** is already passed as an argument to the function. **User don't need to take any input**. Just perform the task on the passed arguments and **return the required result**.
"""

def transpose(A):
    #Your Code Goes Here
    rlen = len(A)
    clen = len(A[0])
    ATR = []
    for c in range(clen):
        ATR_ROW = []
        for r in range(rlen):
            ATR_ROW.append(A[r][c])
        ATR.append(ATR_ROW)
    # print(ATR)
    return ATR

import pandas as pd

A = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
ATR = transpose(A)
dfa = pd.DataFrame(A)
trop = pd.DataFrame(' T ', index=dfa.index, columns=[' '])
dfatr = pd.DataFrame(ATR)
print(pd.concat([dfa, trop, dfatr], axis=1).to_string(index=False, header=False))

A = [
        [1, 2],
        [1, 2],
        [1, 2]
    ]
ATR = transpose(A)
dfa = pd.DataFrame(A)
trop = pd.DataFrame(' T ', index=dfa.index, columns=[' '])
dfatr = pd.DataFrame(ATR)
print(pd.concat([dfa, trop, dfatr], axis=1).to_string(index=False, header=False))

"""**AQ5. Matrix Column Sum**

You are given input as a square NxN matrix, complete the column_sum function so that it returns the sum of each column as a list.
"""

def column_sum(matrix):
  # write your code here
  cols_sum = []
  for c in range(len(matrix[0])):
    cols_sum.append(sum(row[c] for row in matrix))
  # print(cols_sum)
  return cols_sum

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(f"column_sum({matrix}) = {column_sum(matrix)}")

"""**AQ6. Product of elements**

Write a program that returns the product of all elements present in the array.

**Note:** The list with elements is already passed as an argument to the function. **User don't need to take any input**. Just perform the task on the passed arguments and **return the required result**.
"""

def product(lst):
    ''' input:lst-List of elements in integer format
         output:Return the product as result.'''

    result = 1
    # YOUR CODE GOES HERE
    for n in lst:
        result *= n

    return result

lst = [7, 9, 2, 51]
print(f"product({lst}) = {product(lst)}")